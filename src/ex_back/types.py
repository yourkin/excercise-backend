from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional, Union

from pydantic import BaseModel, Field, condecimal, conint, constr, root_validator
from pydantic.types import UUID

from ex_back.core.concurrency import JobStatus


class OrderSide(str, Enum):
    BUY = "buy"
    SELL = "sell"


class OrderType(str, Enum):
    MARKET = "market"
    LIMIT = "limit"


class EventStatus(Enum):
    PENDING = "pending"
    PUBLISHED = "published"
    FAILED = "failed"


class EventType(str, Enum):
    ORDER_SUBMITTED = "OrderSubmitted"
    ORDER_CREATED = "OrderCreated"


class Order(BaseModel):
    # id generated by the database
    id_: str = Field(..., alias="id")
    created_at: datetime

    type_: OrderType = Field(..., alias="type")
    side: OrderSide
    instrument: constr(min_length=12, max_length=12)
    limit_price: Optional[condecimal(decimal_places=2)]
    quantity: conint(gt=0)

    class Config:
        json_encoders = {Decimal: str}


# Command model
class CreateOrderModel(BaseModel):
    type_: OrderType = Field(..., alias="type")
    side: OrderSide
    instrument: constr(min_length=12, max_length=12)
    limit_price: Optional[condecimal(decimal_places=2)]
    quantity: conint(gt=0)

    class Config:
        json_encoders = {Decimal: str}

    @root_validator
    def validator(cls, values: dict):
        if values.get("type_") == "market" and values.get("limit_price"):
            raise ValueError(
                "Providing a `limit_price` is prohibited for type `market`"
            )

        if values.get("type_") == "limit" and not values.get("limit_price"):
            raise ValueError("Attribute `limit_price` is required for type `limit`")

        return values


class CreateOrderResponse(BaseModel):
    event_id: int
    status: EventStatus
    created_at: datetime
    event_type: EventType


class CreateOrderResponseModel(Order):
    id_: Union[str, UUID] = Field(..., alias="id")
    type_: OrderType = Field(..., alias="type")

    class Config:
        orm_mode = True
        json_encoders = {UUID: str}


class OrderWithJobID(BaseModel):
    job_id: str
    order: CreateOrderResponse


class JobModel(BaseModel):
    job_id: str
    status: JobStatus


# Event model
class OrderCreated(CreateOrderModel):
    id_: UUID
    created_at: datetime = Field(default_factory=datetime.utcnow)


class EventOutboxResponse(BaseModel):
    id: int
    event_type: EventType
    event_data: str
    status: EventStatus
    created_at: datetime
    published_at: Optional[datetime]
    failed_at: Optional[datetime]
    error: Optional[str]
    metadata_: Optional[dict]

    class Config:
        orm_mode = True

    # @classmethod
    # def from_orm(cls, orm_instance):
    #     # Create a dictionary of column names and values from the ORM instance
    #     data = {
    #         column.name: getattr(orm_instance, column.name)
    #         for column in orm_instance.__table__.columns
    #     }
    #     return cls(**data)
